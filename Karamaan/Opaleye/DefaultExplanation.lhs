> {-# LANGUAGE FlexibleContexts #-}
> module Karamaan.Opaleye.DefaultExplanation where
>
> import qualified Karamaan.Opaleye.Operators2 as Operators2
> import Karamaan.Opaleye.QueryColspec (QueryColspec)
> import qualified Karamaan.Opaleye.QueryColspec as QueryColspec
> import Karamaan.Opaleye.QueryArr (Query)
> import Karamaan.Opaleye.Wire (Wire)
> import qualified Karamaan.Opaleye.RunQuery as RunQuery
> import Karamaan.Opaleye.RunQuery (QueryRunner)
> import Karamaan.Opaleye.Nullable (Nullable)
> import Data.Profunctor.Product ((***!), p4)
> import Data.Profunctor.Product.Default (Default, def)
> import qualified Database.PostgreSQL.Simple as SQL

Introduction
============

Instances of product-profunctor are very common in Opaleye.  They are
first-class representations of various transformations that need to
occur in certain places.  The 'Default' typeclass from
product-profunctors is used throughout Opaleye to avoid API users
having to write a lot of automatically derivable code, and it deserves
a thorough explanation.

Example
=======

By way of example we will consider the QueryColspec product-profunctor
and how it is used with the 'union' operation.  The version of 'union'
that does not have a Default constraint is called 'union'' and has the
following type.

> union' :: QueryColspec a b
>        -> Query a -> Query a -> Query b
> union' = Operators2.union'

What is the QueryColspec used for here?  Let's take a simple case where
we want to union two queries of type 'Query (Wire Int, Wire String)'

> myQuery1 :: Query (Wire Int, Wire String)
> myQuery1 = undefined -- We won't actually need specific implementations here
>
> myQuery2 :: Query (Wire Int, Wire String)
> myQuery2 = undefined

That means we will be using union' at the type

> union'' :: QueryColspec (Wire Int, Wire String) (Wire Int, Wire String)
>         -> Query (Wire Int, Wire String)
>         -> Query (Wire Int, Wire String)
>         -> Query (Wire Int, Wire String)
> union'' = union'

Since every 'Wire' is actually just a string containing a column name,
'(Wire Int, Wire String)' is a pair of column names.  When we generate
the SQL we need to take the two pairs of column names, generate new
unique names that refer to them and produce these new unique names in
their own value of type '(Wire Int, Wire String)'.  This is exactly
what a value of type

    QueryColspec (Wire Int, Wire String) (Wire Int, Wire String)

allows us to do.

So the next question is, how do we get our hands on a value of that
type?  Well we have 'queryColspecWire' which is a value that allows us
to access the column name within a single wire.

> queryColspecWire :: QueryColspec (Wire a) (Wire a)
> queryColspecWire = QueryColspec.queryColspecWire

QueryColspec is a product-profunctor so we can combine two of them to
work on a pair.

> queryColspecWire2 :: QueryColspec (Wire a, Wire b) (Wire a, Wire b)
> queryColspecWire2 = queryColspecWire ***! queryColspecWire

Then we can use 'queryColspecWire2' in union'.

> theUnion :: Query (Wire Int, Wire String)
> theUnion = union' queryColspecWire2 myQuery1 myQuery2

Now suppose that we wanted to take a union of two queries with columns
in a tuple of size four.  We can make a suitable QueryColspec like
this:

> queryColspecWire4 :: QueryColspec (Wire a, Wire b, Wire c, Wire d)
>                                   (Wire a, Wire b, Wire c, Wire d)
> queryColspecWire4 = p4 (queryColspecWire, queryColspecWire,
>                         queryColspecWire, queryColspecWire)

Then we can pass this QueryColspec to union'.

The problem and 'Default' is the solution
=========================================

Constructing these QueryColspecs explicitly will become very tedious
very fast.  Furthermore it is completely pointless to construct them
explicitly because the correct QueryColspec can automatically be
deduced.  This is where the 'Default' typeclass comes in.

Karamaan.Opaleye.QueryColspec has the Default instance

    instance Default QueryColspec (Wire a) (Wire a) where
      def = queryColspecWire

That means that we know the "default" way of getting a

    QueryColspec (Wire a) (Wire a)

However, if we have a default way of getting one of these, we also
have a default way of getting a

    QueryColspec (Wire a, Wire b) (Wire a, Wire b)

just by using the product-profunctor product operation.  And in the
general case for a product type 'T' with 'n' type parameters we can
automatically deduce the correct value of type

    QueryColspec (T a1 ... an) (T a1 ... an)

(This requires the Default instance for T as generated by
Data.Profunctor.Product.TH.makeAdaptorAndInstance, or an equivalent
instance defined by hand).  It means we don't have to explicitly
specify the QueryColspec value.

Instead of writing 'theUnion' as above, providing the QueryColspec
explicitly, we can instead use a version of union which automatically
uses the default QueryColspec so we don't have to provide it.

> union :: Default QueryColspec a b
>        => Query a -> Query a -> Query b
> union = Operators2.union' def
>
> theUnion' :: Query (Wire Int, Wire String)
> theUnion' = union myQuery1 myQuery2

In the long run this prevents writing a huge amount of boilerplate code.

A further example: QueryRunner
==============================

A 'QueryRunner a b' is the product-profunctor which represents how to
turn run a 'Query a' (currently on Postgres) and return you a list of
rows, each row of type 'b'.  The function which is responsible for
this is 'runQuery'

> runQuery :: QueryRunner a b -> Query a -> SQL.Connection -> IO [b]
> runQuery = RunQuery.runQuery

Basic values of QueryRunner will have the following types

> intRunner :: QueryRunner (Wire Int) Int
> intRunner = undefined -- The implementation is not important here
>
> doubleRunner :: QueryRunner (Wire Double) Double
> doubleRunner = undefined
>
> stringRunner :: QueryRunner (Wire String) String
> stringRunner = undefined
>
> boolRunner :: QueryRunner (Wire Bool) Bool
> boolRunner = undefined

Furthermore we will have basic ways of running queries which return
'Nullable' values, for example

> nullableIntRunner :: QueryRunner (Wire (Nullable Int)) (Maybe Int)
> nullableIntRunner = undefined

If I have a very simple query with a single column of Int then I can
run it using the intRunner.

> myQuery3 :: Query (Wire Int)
> myQuery3 = undefined -- The implementation is not important
>
> runTheQuery :: SQL.Connection -> IO [Int]
> runTheQuery = runQuery intRunner myQuery3

If my query has several columns of different types I need to build up
a larger QueryRunner.

> myQuery4 :: Query (Wire Int, Wire String, Wire Bool, Wire (Nullable Int))
> myQuery4 = undefined
>
> largerQueryRunner :: QueryRunner
>       (Wire Int, Wire String, Wire Bool, Wire (Nullable Int))
>       (Int, String, Bool, Maybe Int)
> largerQueryRunner = p4 (intRunner, stringRunner, boolRunner, nullableIntRunner)
>
> runTheBiggerQuery :: SQL.Connection -> IO [(Int, String, Bool, Maybe Int)]
> runTheBiggerQuery = runQuery largerQueryRunner myQuery4

But having to build up 'largerQueryRunner' was a pain and completely
redundant!  Like the QueryColspec it can be automatically deduced.
Karamaan.Opaleye.RunQuery already gives us default instances for the
following types (plus many others, of course!).

* 'QueryRunner (Wire Int) Int'
* 'QueryRunner (Wire String) String'
* 'QueryRunner (Wire Bool) Bool'
* 'QueryRunner (Wire (Nullable Int)) (Maybe Int)'

Then the Default typeclass machinery automatically deduces the correct
value of the type we want.

> largerQueryRunner' :: QueryRunner
>       (Wire Int, Wire String, Wire Bool, Wire (Nullable Int))
>       (Int, String, Bool, Maybe Int)
> largerQueryRunner' = def

And we can produce a version of 'runQuery' which allows us to write
our query without explicitly passing the product-profunctor value.

> runQueryDef :: Default QueryRunner a b => Query a -> SQL.Connection -> IO [b]
> runQueryDef = RunQuery.runQuery def
>
> runTheBiggerQuery' :: SQL.Connection -> IO [(Int, String, Bool, Maybe Int)]
> runTheBiggerQuery' = runQueryDef myQuery4

Conclusion
==========

Much of the functionality of Opaleye depends on product-profunctors
and many of the values of the product-profunctors are automatically
derivable from some base collection.  The 'Default' typeclass and its
associated instance derivations are the mechanism through which this
happens.
